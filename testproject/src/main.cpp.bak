#include <iostream>
#include <vector>
#include <stdio.h>
#include <hwge/hwge.hpp>
#include <hwge/status_codes.hpp>
#include <hwge/shader_utils.hpp>
#include <hwge/glew.hpp>
#include <hwge/utils.hpp>
#include <hwge/vboutils.hpp>
#include <hwge/objloader.hpp>
#include <hwge/glfw.hpp>
#include <hwge/bmp.hpp>
#include <hwge/png.hpp>
#include <hwge/args.hpp>
#include <hwge/freetype.hpp>
#include <string>
#include <GL/glew.h>
#include <GL/glut.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtx/transform.hpp>

using namespace std;
using namespace HWGE;

glm::mat4 viewMatrix, projectionMatrix;
glm::vec3 position = glm::vec3(0, 0, 5);
float horizontalAngle = 3.14f;
float verticalAngle = 0.0f;
float initalFoV = 45.0f;
float speed = 3.0f;
float mouseSpeed = 0.0005f;

bool useControls = false;

void computeMatFromInput(GLFWwindow* window, int width, int height) {
    static double lastTime = glfwGetTime();

    double currentTime = glfwGetTime();
    float deltaTime = float(currentTime - lastTime);

    double xPos, yPos;
    glfwGetCursorPos(window, &xPos, &yPos);

    glfwSetCursorPos(window, width / 2, height / 2);

    horizontalAngle += mouseSpeed * float(width / 2 - xPos);
    verticalAngle += mouseSpeed * float(height / 2 - yPos);

    glm::vec3 direction(
        cos(verticalAngle) * sin(horizontalAngle),
        sin(verticalAngle),
        cos(verticalAngle) * sin(horizontalAngle)
    );

    glm::vec3 right(
        sin(horizontalAngle - 3.14f / 2.0f),
        0,
        cos(horizontalAngle - 3.14f / 2.0f)
    );

    glm::vec3 up = glm::cross(right, direction);

    if(glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS) {
        position += direction * deltaTime * speed;
    }

    if(glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS) {
        position -= direction * deltaTime * speed;
    }

    if(glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS) {
        position += right * deltaTime * speed;
    }

    if(glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS) {
        position -= right * deltaTime * speed;
    }

    float fov = initalFoV;

    projectionMatrix = glm::perspective(glm::radians(fov), (float) width / (float) height, 0.1f, 100.0f);
    viewMatrix = glm::lookAt(
        position,
        position + direction,
        up
    );

    lastTime = currentTime;
}

int main(int argc, char** argv) {
    HWGE::Args args(argc, argv);
    HWGE::init();

    if(args.hasOption("--use-controls")) {
        useControls = true;
    }

    if(!GLFW::init()) return HWGE_STATUS_ERROR;

    glfwWindowHint(GLFW_SAMPLES, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    int width = 1024;
    int height = 768;

    GLFWwindow* window = GLFW::createWindow(width, height, "HWGE Version: " + HWGE::version());
    glfwMakeContextCurrent(window);

    if(!GLEW::init()) return HWGE_STATUS_ERROR;

    int glutArgc = 1;
    char *glutArgv[1] = { (char*)"Something" };
    glutInit(&glutArgc, glutArgv);

    Utils::displayOpenGLVersions();

    glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);
    if(useControls) glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

    glfwPollEvents();
    glfwSetCursorPos(window, width / 2, height / 2);

    glClearColor(0.0f, 0.75f, 1.0f, 0.0f);

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    //glEnable(GL_CULL_FACE);
    //glEnable(GL_TEXTURE_2D);

    GLuint vao;
    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);

    /*string vsStr = Utils::loadFileAsString("assets/shaders/tex.vs");
    string fsStr = Utils::loadFileAsString("assets/shaders/tex.fs");*/

    GLuint programID = ShaderUtils::load("assets/shaders/tex.vs", "assets/shaders/tex_transparent.fs");
    
    GLuint matrixID = glGetUniformLocation(programID, "MVP");
    GLuint viewMatrixID = glGetUniformLocation(programID, "V");
    GLuint modelMatrixID = glGetUniformLocation(programID, "M");

    //GLuint texture = Utils::loadDDS("assets/textures/stone.dds");
    //GLuint texture = Utils::loadBMP("assets/textures/stone.bmp");
    //Image::BMP bmp("assets/textures/stone.bmp");
    //GLuint texture = bmp.openGLTexture();
    Image::PNG png("assets/textures/thing.png");
    GLuint texture = png.load();

    GLuint textureID = glGetUniformLocation(programID, "texSampler");

    vector<glm::vec3> vertices;
    vector<glm::vec2> uvs;
    vector<glm::vec3> normals;

    cout << "Loading objects..." << endl;
    bool res = OBJLoader::loadOBJ("assets/models/cube.obj", vertices, uvs, normals);

    vector<unsigned short> indices;
    vector<glm::vec3> indexedVertices;
    vector<glm::vec2> indexedUVs;
    vector<glm::vec3> indexedNormals;

    cout << "VBO indexing..." << endl;
    Utils::VBO::indexVBO(vertices, uvs, normals, indices, indexedVertices, indexedUVs, indexedNormals);

    cout << "Creating buffer objects..." << endl;
    GLuint vbo;
    glGenBuffers(1, &vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, indexedVertices.size() * sizeof(glm::vec3), &indexedVertices[0], GL_STATIC_DRAW);

    GLuint uvbo;
    glGenBuffers(1, &uvbo);
    glBindBuffer(GL_ARRAY_BUFFER, uvbo);
    glBufferData(GL_ARRAY_BUFFER, indexedUVs.size() * sizeof(glm::vec2), &indexedUVs[0], GL_STATIC_DRAW);

    GLuint nbo;
    glGenBuffers(1, &nbo);
    glBindBuffer(GL_ARRAY_BUFFER, nbo);
    glBufferData(GL_ARRAY_BUFFER, indexedNormals.size() * sizeof(glm::vec3), &indexedNormals[0], GL_STATIC_DRAW);

    GLuint ebo;
    glGenBuffers(1, &ebo);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned short), &indices[0], GL_STATIC_DRAW);

    glUseProgram(programID);
    GLuint lightID = glGetUniformLocation(programID, "lightPos");

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    //Graphics::Text2D text2D("assets/fonts/font.ttf", width, height); // text2D(width, height, "assets/fonts/font2.png");
    //text2D.loadPNG();
    FreeType::FontData font;
    font.init("assets/fonts/font.ttf", 16);

    double lastTime = glfwGetTime();
    int nbFrames = 0;

    cout << "Starting game loop..." << endl;
    do {
        double currentTime = glfwGetTime();
        nbFrames++;
        if(currentTime - lastTime >= 1.0) {
            printf("%f ms/frame\n", 1000.0 / double(nbFrames));
            nbFrames = 0;
            lastTime = currentTime;
        }

        //glEnable(GL_BLEND);
        //glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glEnable(GL_CULL_FACE);

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        //text2D.renderText("Hello!", 25.0f, 25.0f, 1.0f, glm::vec3(0.5f, 0.8f, 0.2f));

        //glColor3ub(0, 0, 0xff);
        //glLoadIdentity();
        //glRotatef(cnt1, 0, 0, 1);
        //glScalef(1, 0.8 + 0.3 * cos(cnt1 / 5), 1);
        //glRasterPos2f(-0.4f, 0.35f);
        //glTranslatef(-180, 0, 0);

        glBindVertexArray(vao);

        glUseProgram(programID);

        if(useControls) {
            computeMatFromInput(window, width, height);
        } else {
            viewMatrix = glm::lookAt(
                glm::vec3(4, 3, 3),
                glm::vec3(0, 0, 0),
                glm::vec3(0, 1, 0)
            );

            projectionMatrix = glm::perspective(glm::radians(45.0f), (float) width / (float) height, 0.1f, 100.0f);
        }
        glm::mat4 modelMatrix(1.0);
        glm::mat4 mvp = projectionMatrix * viewMatrix * modelMatrix;

        glUniformMatrix4fv(matrixID, 1, GL_FALSE, &mvp[0][0]);
        glUniformMatrix4fv(modelMatrixID, 1, GL_FALSE, &modelMatrix[0][0]);
        glUniformMatrix4fv(viewMatrixID, 1, GL_FALSE, &viewMatrix[0][0]);

        glm::vec3 lightPos(4, 4, 4);
        glUniform3f(lightID, lightPos.x, lightPos.y, lightPos.z);

        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, texture);
        glUniform1i(textureID, 0);

        // Start draw
        glEnableVertexAttribArray(0);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glVertexAttribPointer(
            0, // attribute 0
            3, // size
            GL_FLOAT, // type
            GL_FALSE, // normalized?
            0, // stride
            (void*) 0
        );

        glEnableVertexAttribArray(1);
        glBindBuffer(GL_ARRAY_BUFFER, uvbo);
        glVertexAttribPointer(
            1, // attribute 1
            2, // size
            GL_FLOAT, // type
            GL_FALSE, // normalized?
            0, // stride
            (void*) 0
        );

        // normals
        glEnableVertexAttribArray(2);
        glBindBuffer(GL_ARRAY_BUFFER, nbo);
        glVertexAttribPointer(
            2, // attribute 2
            3, // size
            GL_FLOAT, // type
            GL_FALSE, // normalized?
            0, // stride
            (void*) 0
        );

        // draw the triangle
        //glDrawArrays(GL_TRIANGLES, 0, vertices.size());

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
        
        glDrawElements(
            GL_TRIANGLES,
            indices.size(),
            GL_UNSIGNED_SHORT,
            (void*) 0
        );

        glDisableVertexAttribArray(0);
        glDisableVertexAttribArray(1);
        glDisableVertexAttribArray(2);
        // End Draw

        //Graphics::Text2D::print(width, height, "Hello!", 100, 100, 100);
        //text2D.printString("Hello!", 10, 500, 60);
        
        glMatrixMode(GL_PROJECTION);
        glPushMatrix();
        glLoadIdentity();
        glOrtho(0.0, width, height, 0.0, -1.0, 10.0);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        glDisable(GL_CULL_FACE);
        glClear(GL_DEPTH_BUFFER_BIT);

        glBegin(GL_QUADS);
        glColor3f(1.0f, 0.0f, 0.0f);
        glVertex2f(0.0, 0.0);
        glVertex2f(10.0, 0.0);
        glVertex2f(10.0, 10.0);
        glVertex2f(0.0, 10.0);
        glEnd();

        glMatrixMode(GL_PROJECTION);
        glPopMatrix();
        glMatrixMode(GL_MODELVIEW);

        //FreeType::print(font, 320, 200, "HI!");
        //glPopMatrix();
        
        glfwSwapBuffers(window);
        glfwPollEvents();
    } while(!glfwWindowShouldClose(window));

    glDeleteBuffers(1, &vbo);
    glDeleteBuffers(1, &uvbo);
    glDeleteBuffers(1, &nbo);
    glDeleteProgram(programID);
    glDeleteTextures(1, &texture);
    glDeleteVertexArrays(1, &vao);

    font.clean();

    glfwTerminate();
    return HWGE_STATUS_OK;
}